/*
 * This file was generated by the scsynth tool, and is availablefor use under
 * the MIT license. More information can be found at
 * https://github.com/arminalaghi/scsynth/
 */
module ReSC_wrapper_asd( //handles stochastic/binary conversion for ReSC
	input [9:0] x_bin, //binary value of input
	input start, //signal to start counting
	output reg done, //signal that a number has been computed 
	output reg [9:0] z_bin, //binary value of output

	input clk,
	input reset
);


	wire [3:0] x_stoch;
	wire [4:0] w_stoch;
	wire z_stoch;
	wire init;
	wire running;

	//RNGs for binary->stochastic conversion
	wire [39:0] randx;
	LFSR_40_bit_added_zero_asd rand_gen_x (
		.seed (40'd1),
		.data (randx),
		.enable (running),
		.restart (init),
		.clk (clk),
		.reset (reset)
	);
	wire[9:0] randx0;
	assign randx0 = randx[9:0];

	wire[9:0] randx1;
	assign randx1 = randx[19:10];

	wire[9:0] randx2;
	assign randx2 = randx[29:20];

	wire[9:0] randx3;
	assign randx3 = randx[39:30];

	assign x_stoch[0] = randx0 < x_bin;

	assign x_stoch[1] = randx1 < x_bin;

	assign x_stoch[2] = randx2 < x_bin;

	assign x_stoch[3] = randx3 < x_bin;

	wire [9:0] randw;
	reversed_counter_10_bit_asd rand_gen_w (
		.out (randw),
		.enable (running),
		.restart (init),
		.clk (clk),
		.reset (reset)
	);

	wire [9:0] randw0;
	assign randw0 = randw;

	wire [9:0] randw1;
	assign randw1 = randw;

	wire [9:0] randw2;
	assign randw2 = randw;

	wire [9:0] randw3;
	assign randw3 = randw;

	wire [9:0] randw4;
	assign randw4 = randw;

	STRAUSS_asd ReSC (
		.x (x_stoch),
		.randw (randw0),
		.z (z_stoch)
	);

	reg [9:0] count; //count clock cycles
	wire [9:0] neg_one;
	assign neg_one = -1;

	//Finite state machine. States:
	//0: finished, in need of resetting
	//1: initialized, start counting when start signal falls
	//2: running
	reg [1:0] cs; //current FSM state
	reg [1:0] ns; //next FSM state
	assign init = cs == 1;
	assign running = cs == 2;

	always @(posedge clk or posedge reset) begin
		if (reset) cs <= 0;
		else begin
			cs <= ns;
			if (running) begin
				if (count == neg_one) done <= 1;
				count <= count + 1;
				z_bin <= z_bin + z_stoch;
			end
		end
	end

	always @(*) begin
		case (cs)
			0: if (start) ns = 1; else ns = 0;
			1: if (start) ns = 1; else ns = 2;
			2: if (done) ns = 0; else ns = 2;
			default ns = 0;
		endcase
	end

	always @(posedge init) begin
		count <= 0;
		z_bin <= 0;
		done <= 0;
	end
endmodule
