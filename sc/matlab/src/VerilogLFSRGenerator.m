%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Copyright (C) 2016 Armin Alaghi and N. Eamon Gaffney
%%
%% This program is free software; you can resdistribute and/or modify it under
%% the terms of the MIT license, a copy of which should have been included with
%% this program at https://github.com/arminalaghi/scsynth
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

function VerilogLFSRGenerator (dataLen, addZero, moduleName, taps=0)

    %generates an LFSR Verilog file
    %Parameters:
    % dataLen   : the length of the LFSR in bits
    % addZero   : if 0, produces a normal LFSR which does not have the
    %             all-zero state, if 1, artificially adds an all-zero state
    %             (useful in SC)
    % moduleName: the name of the verilog module
    
    %Optional Parameters:
    % taps: the location of XORs obtained from http://www.newwaveinstruments.com
    %       /resources/articles/m_sequence_linear_feedback_shift_register_lfsr.h
    %       tm. If no taps are supplied, taps will be autamatically selected for
    %       dataLen between 3 and 20. 24. or 32
    
  if taps==0
     switch(dataLen)
      case 3
        taps = [3, 2];
      case 4
        taps = [4, 3];
      case 5
        taps = [5, 3];
      case 6
        taps = [6, 5];
      case 7
        taps = [7, 6];
      case 8
        taps = [8, 7, 6, 1];
      case 9
        taps = [9, 5];
      case 10
        taps = [10, 7];
      case 11
        taps = [11, 9];
      case 12
        taps = [12, 11, 10, 4];
      case 13
        taps = [13, 12, 11, 8];
      case 14
        taps = [14, 13, 12, 2];
      case 15
        taps = [15, 14];
      case 16
        taps = [16, 15, 13, 4];
      case 17
        taps = [17, 14];
      case 18
        taps = [18, 11];
      case 19
        taps = [19, 18, 17, 14];
      case 20
        taps = [20, 17];
      case 24
        taps = [24, 23, 22, 17];
      case 32
        taps = [32, 31, 30, 10];
  
      otherwise
        taps = [3, 2];
    end 
  end

	fileName = sprintf('%s.v', moduleName);
  header = ['/*\n * This file was generated by the scsynth tool, and is ava',...
            'ilablefor use under\n * the MIT license. More information can ',...
            'be found at\n * https://github.com/arminalaghi/scsynth/\n */\n'];
  
  fp = fopen(fileName, 'w');

  fprintf(fp, header);
	fprintf(fp, 'module %s(//Linear feedback shift register\n', moduleName);

	fprintf(fp, '\tinput [%d:0] seed, //Initial value\n', dataLen-1);
	fprintf(fp, '\toutput [%d:0] data, //Current value\n', dataLen-1);
  fprintf(fp, '\tinput enable, //When on, new state every clock cycle\n');
  fprintf(fp, '\tinput restart, //Restart the LFSR at its seed state\n\n');
  fprintf(fp, '\tinput reset,\n');
  fprintf(fp, '\tinput clk\n');
  fprintf(fp, ');\n');
  
	fprintf(fp, '\n\treg [%d:0] shift_reg;\n\twire shift_in;\n', dataLen-1);
	fprintf(fp, '\n\talways @(posedge clk or posedge reset) begin\n');
	fprintf(fp, '\t\tif (reset) shift_reg <= seed;\n');
  fprintf(fp, '\t\telse if (restart) shift_reg <= seed;\n');
	fprintf(fp, '\t\telse if (enable) shift_reg <= {shift_reg[%d:0], shift_in};', dataLen-2);
  fprintf(fp, '\n\tend\n\n');

	fprintf(fp, '\n\twire xor_out;\n\tassign xor_out = shift_reg[%d]', taps(1)-1);
	for i=2:length(taps)
		fprintf(fp, ' ^ shift_reg[%d]', taps(i)-1);
	end
	fprintf(fp, ';\n');

	if(addZero)
		fprintf(fp, '\n\twire zero_detector;\n\tassign zero_detector = ~(|(shift_reg[%d:0]));', dataLen-2);
		fprintf(fp, '\n\tassign shift_in = xor_out ^ zero_detector;\n');
	else
		fprintf(fp, '\n\tassign shift_in = xor_out;\n');
	end
		fprintf(fp, '\n\n\tassign data = shift_reg;\nendmodule\n');


	%fflush(fp);
	fclose(fp);
end
